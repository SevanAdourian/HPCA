#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>
// #include <cuda.h>
// #include <mpi.h>
#include <string.h>

#include "model.h"

#define PARAM_FILE "c_tab4"

struct model_struct struct_model;
struct param_struct struct_param;
static int nline = 0;

extern void store_model_(float *vp, float *vs, float *rho, float *theta){
  struct_model.vp0[nline] = *vp;
  struct_model.vs0[nline] = *vs;
  struct_model.rh0[nline] = *rho;
  struct_model.th0[nline] = *theta;
  nline++;

  free(vp0);
  free(vs0);
  free(rh0);
  free(th0);

}

extern void read_model_(char *);
static char usage[] = "Use: %s model_filename, depth, dr, rmax, output_filename, facmin, facmax\n";

int main(int argc, char *argv[]) {
  char *model_filename, *output_filename;
  int nkmin = 100;
  float Pp[3], Pm[3], SVp[3], SVm[3], SHp[3], SHm[3];
  float Ep, Em;
  float *q, *w, *v, *qE, *wE;
  float B[3], C[3];
  float E, F;	
  /*real	:: D(3:4) */
  float facmin, facmax;

  float *rv;
  int jh, jk, jr, nr;
  float r, rmin, rmax, dr;
  float *Bmat, *Cmat, *Dmat, *Emat, *Fmat;
  float hmin, hmax;
  float depth;
  FILE* int_const;
  
  /* read the command line arguments */

  if (argc != 8) {
    fprintf(stderr, usage, argv[0]);
    return EXIT_FAILURE;
  }

  model_filename = malloc((strlen(argv[1]) + 1) * sizeof(char));
  output_filename = malloc((strlen(argv[5]) + 1) * sizeof(char));

  model_filename = argv[1];
  depth = atof(argv[2]) * 1000; /* depth of the source */
  dr = atof(argv[3]) * 1000; /* horizontal interval */
  rmax = atof(argv[4]) * 1000; /* max. horiz. distance */
  output_filename = argv[5];
    
  /* Factors defining the k-integration upper limit and step */  
  facmin = atof(argv[6]);
  facmax = atof(argv[7]);

  /* read the model  (vp, vs, rho, thickness) */
  read_model_(model_filename);
  printf("vs0 = %f\n", struct_model.vs0[1]);
  
  /* generate the horizontal distances vector */
  rmin = 0;
  nr = (int)((rmax-rmin)/dr+1.5);

  rv = malloc(nr * sizeof(float));
  Bmat = malloc(3 * nr * sizeof(float));
  Cmat = malloc(3 * nr * sizeof(float));
  Dmat = malloc(2 * nr * sizeof(float));
  Emat = malloc(nr * sizeof(float));
  Fmat = malloc(nr * sizeof(float));

  for (jr = 0; jr < nr-1; jr++) {
    rv 	= ( rmin + jr*dr);
  }
    
  /*     ! write the header of the output table */
  /*     open(unit=10, file=output_filename, status='unknown') */
  /*     write(10,'(a)') 'Model: 1st Nb layers, 2nd th, 3th vp, 4th vs, 5th rho' */
  /*     write(10,'(i4)')	N-1 */
  /*     write(10,'(100f12.2)') 	th0 ! neet to change so it is Nf12.2 */
  /*     write(10,'(100f12.2)') 	vp0 ! neet to change so it is Nf12.2 */
  /*     write(10,'(100f12.2)') 	vs0 ! neet to change so it is Nf12.2 */
  /*     write(10,'(100f12.2)') 	rh0 ! neet to change so it is Nf12.2 */
  /*     write(10,'(a)') 'Depth' */
  /*     write(10,'(10f12.2)') 	depth */
  /*     write(10,'(a)') 'Distances: nr, rmin, rmax' */
  /*     write(10,'(i10, 2f15.2)') nr, rmin, rmax */
  /*     write(10,'(a)') 'k-integration parameters' */
  /*     write(10,'(2f12.2)') facmin, facmax */

  /*     ! 'acotab' insert in the model a dummy interface at the depth of the source */
  int htol = 9;
  acotab(depth, htol, struct_model);

  /*     ! 'discotab' evaluates the discontinuities in the potentials, generated by the source */
  discotabE(M, Pp, Pm, SVp, SVm, SHp, SHm, Ep, Em);

  /*     ! calculation for distance r=0 */
  jr = 0;
  hmin = th[0];
  for(jh = 2; jh < Np; jh++){
    hmin = min(hmin,th(jh)); /* Coucou le built-in fortran ! */
  }

  kmax	= facmax / hmin;
  for (int ii = 1;  i < sizeof(th) / sizeof(float); ii++) {
    hmax += th[ii];
  }
  
  dk	= 1 / facmin / hmax; /* Weird, right? */
  nk	= kmax / dk;
  if( nk < nkmin); nk = nkmin;
  kv = malloc(nk * sizeof(float));
  kmin = dk/100;

  for(jk = 0; jk < nk -1; jk++){
    kv = kmin+jk*dk;
  }

  /* 	! calculation of the potentials at the surface */
  q = malloc(3 * nk * sizeof(float));
  w = malloc(3 * nk * sizeof(float));
  v = malloc(3 * nk * sizeof(float));
  qE = malloc(nk * sizeof(float));
  wE = malloc(nk * sizeof(float));
  
  calcqwvE(Pp, Pm, SVp, SVm, SHp, SHm, Ep, Em, q, w, v, qE, wE);

  /* 	! calculation of the elementary displacements at the origin */
  calc_BCD0E_(q, w, v, qE, wE, B, C, D, E, F);
    
  /* Bmat(:,jr) = B*dk; */
  /* Cmat(:,jr) = C*dk; */
  /* Dmat(:,jr) = D*dk; */
  /* Emat(  jr) = E*dk; */
  /* Fmat(  jr) = F*dk; */
  
  /* 	deallocate(q,w,v,qE,wE) */
  /* 	deallocate(kv) */
  
  /* 	do jr=2,nr */
  /* 		r = rv(jr) */
  /* 		kmax	= facmax/hmin */
  /* 		if(r < hmin) kmax = facmax/r */
  /* 		dk	= 1./facmin/hmax */
  /* 		if(r > hmax) dk = 1./facmin/r */
  /* 		nk	= kmax/dk */
  /* 		if( nk < nkmin) nk = nkmin */
  /* !		write(*,'(a, f9.2, a, e9.4, a, e9.4, a, i5)') ' r= ', r, ' dk= ', dk, ' kmax= ', kmax, ' nk= ', nk */
  /*         	allocate(kv(nk)) */
  /* 		kmin = dk/100. */
  /*         	kv    = (/ ( kmin+jk*dk, jk=0,(nk-1) ) /) */

  /* 		! calculation of the potentials at the surface */
  /* 		allocate(q(0:2,nk), w(0:2,nk), v(0:2,nk), qE(nk), wE(nk)) */
  /* 		call calcqwvE(Pp, Pm, SVp, SVm, SHp, SHm, Ep, Em, q, w, v, qE, wE) */

  /* 		! calculation of the elementary displacements at the distance r */
  /* 		call calc_coeffsE(q, w, v, qE, wE, r, B, C, D, E, F) */
  /* 		Bmat(:,jr) = B*dk */
  /* 		Cmat(:,jr) = C*dk */
  /* 		Dmat(:,jr) = D*dk */
  /* 		Emat(  jr) = E*dk */
  /* 		Fmat(  jr) = F*dk */
  /* 		deallocate(q,w,v,qE,wE) */
  /* 		deallocate(kv) */

  /* !		write(*,'(9e15.7)') rv(jr), Bm(:,jr), Cm(:,jr), Dm(:,jr) */
  /* 		write(*,'(t1,f4.1,"%")') 100.*float(jr-1)/float(nr) */
  /* 	enddo */

  /* 	Bmat = Bmat/4./M_PI */
  /* 	Cmat = Cmat/4./M_PI */
  /* 	Dmat = Dmat/4./M_PI */
  /* 	Emat = Emat/4./M_PI */
  /* 	Fmat = Fmat/4./M_PI */
  /* 	write(10,'(a)') 'elementary displacements' */
  /* 	do jr=1,nr */
  /* 		write(10,'(12e15.7)') depth, rv(jr), Bmat(:,jr), Cmat(:,jr), Dmat(:,jr), Emat(jr), Fmat(jr) */
  /* 	enddo */
  /* 	close(10) */

  free(rv);
  free(Bmat);
  free(Cmat);
  free(Dmat);
  free(Emat);
  free(Fmat);
  
  /* stop */
  
  return EXIT_SUCCESS;
}
